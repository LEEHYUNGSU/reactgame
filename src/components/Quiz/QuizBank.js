export const allQuestionsBank = [
  {
    question: 'HTML의 정의와 가장 유사한 것을 고르세요.',
    options: ['HTML은 스타일시트 언어다.', 'HTML은 웹 문서의 기능 구현을 위한 언어다.', 'HTML은 구조를 표현하기 위한 언어다.'],
    correctAnswer: 'HTML은 구조를 표현하기 위한 언어다.',
  },
  {
    question: '다음 중 CSS에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['CSS는 웹 애플리케이션의 스타일링을 담당하는 스타일 시트 언어다.', '화려하고 심미적인 부분 뿐만 아니라 콘텐츠를 적당한 위치에 배치하는 레이아웃도 CSS로 수행할 수 있다.', 'CSS는 웹 디자이너에게 필요한 역량이므로, 프론트엔드 개발자는 JavaScript와 같은 프로그래밍 언어에만 집중하면 된다.'],
    correctAnswer: 'CSS는 웹 디자이너에게 필요한 역량이므로, 프론트엔드 개발자는 JavaScript와 같은 프로그래밍 언어에만 집중하면 된다.',
  },
  {
    question: '다음 중 와이어프레임에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['단순한 선이나, 도형으로 인터페이스를 시각적으로 묘사한 것이다.', '와이어프레임만 봐도 어떤 목적을 가진 프로그램인지 유추할 수 있다.', '와이어프레임은 보통 HTML 문서로 작성한다.'],
    correctAnswer: '와이어프레임은 보통 HTML 문서로 작성한다.',
  },
  {
    question: '다음 중 Flexbox에 대한 설명으로 맞는 것을 고르세요.',
    options: ['하나의 요소에 display : flex; 속성과 flex-grow : 1; 속성이 동시에 적용되는 경우도 있다.', 'flex 속성의 기본값은 1, 0, auto 이다.', 'flex 속성값은 순서대로 수축 지수, 팽창 지수, 기본 크기이다.'],
    correctAnswer: '하나의 요소에 display : flex; 속성과 flex-grow : 1; 속성이 동시에 적용되는 경우도 있다.',
  },
  {
    question: '다음 중 부모 요소에 적용해야 하는 Flexbox에 속성으로 맞는 것을 고르세요.',
    options: ['flex', 'justify-content', 'wrap-reverse'],
    correctAnswer: 'justify-content',
  },
  {
    question: '다음 중 flex 속성에 대한 설명으로 맞지 않는 것을 고르세요.',
    options: ['요소의 크기는 flex-basis 의 값으로 항상 유지된다.', 'flex-grow 의 값이 0 일 경우 요소의 크기는 늘어나지 않는다.', 'flex-grow 속성과 flex-shrink 속성을 함께 사용하는 것은 권장되지 않는다.'],
    correctAnswer: '요소의 크기는 flex-basis 의 값으로 항상 유지된다.',
  },
  {
    question: '다음 중 CLI에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['입력하는 글자와 출력되는 글자로 컴퓨터와 소통할 수 있다.', '키보드의 입력을 확인하고 편집할 수 있는 한 줄의 공간을 프롬프트라고 한다.', '대부분의 PC에서 유료로 이용 가능하며, WIndows가 대표적이다.'],
    correctAnswer: '대부분의 PC에서 유료로 이용 가능하며, WIndows가 대표적이다.',
  },
  {
    question: '다음 중 CLI 명령어와 설명의 연결이 올바르지 않은 것을 고르세요.',
    options: ['mkdir <folder_name>: 현재 경로에 폴더를 생성합니다.', 'cat <file_name>: 현재 경로에 파일을 생성합니다.', 'rm -rf <folder_name> : 폴더를 삭제합니다.'],
    correctAnswer: 'cat <file_name>: 현재 경로에 파일을 생성합니다.',
  },
  {
    question: 'ls 명령어에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['현재 위치에 포함된 파일이나 하위 폴더의 리스트를 출력하는 명령어이다.', 'ls -a를 입력할 경우 숨어 있는 폴더나 파일을 출력한다.', 'ls -l을 입력했을 때 포맷으로 -rw-r--r--이 출력되었다면 cd 명령어로 진입이 가능하다.'],
    correctAnswer: 'ls -l을 입력했을 때 포맷으로 -rw-r--r--이 출력되었다면 cd 명령어로 진입이 가능하다.',
  },
  {
    question: 'Node.js에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['nvm은 Node.js의 패키지 매니저의 이름이다.', 'Node.js의 등장으로 JavaScript를 통해 웹 페이지를 구성하는 것을 넘어 서버를 구축하는 등, 활용 폭이 크게 확장되었다.', 'CLI 환경에서 node <file_name> 명령어를 입력하면 작성한 코드가 Node.js에서 실행된다.'],
    correctAnswer: 'nvm은 Node.js의 패키지 매니저의 이름이다.',
  },
  {
    question: 'package.json에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['package.json에는 해당 프로그램을 실행시키기 위한 모듈의 정보, 실행 방법, 테스트 하는 방법 등이 명시되어 있다.', '프로젝트 코드를 전달할 때 package.json에 포함되어 있는 모듈을 모두 전달해 주어야 한다.', 'npm install 명령어로 package.json에 포함되어 있는 모듈을 설치할 수 있다.'],
    correctAnswer: '프로젝트 코드를 전달할 때 package.json에 포함되어 있는 모듈을 모두 전달해 주어야 한다.',
  },
  {
    question: 'Git을 이용한 버전 관리의 필요성으로 가장 거리가 먼 설명을 고르세요.',
    options: ['파일의 변경 이력을 저장하고, 필요시 이전 버전으로 돌아갈 수 있다.', '어떤 변경 사항이 발생했는지 알아보기 쉬우므로, 협업에 유리하다.', '프로젝트 코드를 전달할 때 포함되어 있는 모든 모듈을 전달하지 않아도 된다.'],
    correctAnswer: '프로젝트 코드를 전달할 때 포함되어 있는 모든 모듈을 전달하지 않아도 된다.',
  },
  {
    question: 'Git과 Github에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['개발자의 코드를 효율적으로 관리하기 위한 분산형 버전 관리 시스템이다.', '특정 시점에 백업된 복사본을 만드는 작업을 commit이라고 한다.', 'Github으로부터 호스팅 되고 있는 오픈 소스 프로젝트에 기여하기 위해서는 특별한 권한이 필요하다.'],
    correctAnswer: 'Github으로부터 호스팅 되고 있는 오픈 소스 프로젝트에 기여하기 위해서는 특별한 권한이 필요하다.',
  },
  {
    question: '다음 중 Git에 업로드 되어 있는 오픈 소스의 기여자(contributors)가 되기 위한 작업에 대한 설명으로 바르지 않은 것을 고르세요.',
    options: ['fork: 오픈 소스 코드가 업로드 되어 있는 원격 저장소(Remote Repository)에서 나의 원격 저장소로 가지고 오는 과정', 'clone: 원격 저장소에서 내 컴퓨터(Local Repository)로 가지고 오는 과정', 'pull: 작업한 변경 사항을 소스코드에 즉시 반영하는 과정'],
    correctAnswer: 'pull: 작업한 변경 사항을 소스코드에 즉시 반영하는 과정',
  },
  {
    question: '다음 중 DOM에 대한 설명 중 옳은 것을 고르세요.',
    options: ['Element는 Node의 상위 개념이다.', 'HTML의 구조가 자바스크립트 객체의 구조와 같이 트리 구조로 되어 있다.', 'DOM은 window 객체를 통해 HTML에 접근한다.'],
    correctAnswer: 'HTML의 구조가 자바스크립트 객체의 구조와 같이 트리 구조로 되어 있다.',
  },
  {
    question: '다음 중 배열 내장 고차 함수가 아닌 것을 고르세요.',
    options: ['Array.prototype.map()', 'Array.prototype.reduce()', 'Array.prototype.unshift()'],
    correctAnswer: 'Array.prototype.unshift()',
  },
  {
    question: '다음 문제를 해결하기 위한 가장 적절한 배열 내장 고차 함수를 고르세요. A는 새로 노트북을 사기 위해서 검색을 해보았고, 총 4개의 노트북을 구매 목록으로 선정했습니다. 각 노트북이 어떤 회사에서 제조되었는지 확인하기 위해서, 4개 노트북에 대응되는 브랜드 정보를 확인하고자 합니다.',
    options: ['Array.prototype.map()', 'Array.prototype.every()', 'Array.prototype.some()'],
    correctAnswer: 'Array.prototype.map()',
  },
  {
    question: '다음 문제를 해결하기 위한 가장 적절한 배열 내장 고차 함수를 고르세요. A는 티(tea)를 매우 좋아합니다. 음료 중 티(tea) 종류만 따로 분류하려고 합니다.',
    options: ['Array.prototype.find()', 'Array.prototype.map()', 'Array.prototype.filter()'],
    correctAnswer: 'Array.prototype.filter()',
  },
  {
    question: '다음 문제를 해결하기 위한 가장 적절한 배열 내장 고차 함수를 고르세요.A는 최근 Node.js 웹 애플리케이션 프레임워크인 Express를 학습하고 있습니다.친구 B가 학습을 도와주기 위해 관련 레퍼런스들을 제공해 주었습니다. A는 이 레퍼런스들을 읽고, 요약하여 자신의 블로그에 TIL을 적고자 합니다.',
    options: ['Array.prototype.every()', 'Array.prototype.filter()', 'Array.prototype.reduce()'],
    correctAnswer: 'Array.prototype.reduce()',
  },
  {
    question: '생성자 (constructor) 함수에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['인스턴스 객체를 생성하고 초기화하는 메서드이다.', '클래스 내에서 생성자 함수를 두 번 이상 쓸 수 있다.', '생성자 함수를 작성하지 않으면 기본 생성자(default constructor)가 제공된다.'],
    correctAnswer: '클래스 내에서 생성자 함수를 두 번 이상 쓸 수 있다.',
  },
  {
    question: 'super 키워드에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['부모 클래스의 함수를 호출할 때 사용된다.', '생성자 함수 내에서 super 키워드는 두 번 이상 호출할 수 있다.', '생성자 함수 내에서 this 키워드가 나오기 전에 사용돼야 한다.'],
    correctAnswer: '생성자 함수 내에서 super 키워드는 두 번 이상 호출할 수 있다.',
  },
  {
    question: 'Promise의 세 가지 상태에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['이행(fulfilled) 상태는 이행하지도, 거부하지도 않은 초기 상태이다.', '거부(rejected) 상태는 연산(operation)이 실패한 상태이다.', '대기(pending) 상태가 있다.'],
    correctAnswer: '이행(fulfilled) 상태는 이행하지도, 거부하지도 않은 초기 상태이다.',
  },
  {
    question: 'Promise.all에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['Promise.all의 전달인자는 배열이다.', 'Promise.all은 동시에 두 개 이상의 Promise 요청을 한꺼번에 실행하는 함수이다.', 'Promise.all에 두 개 이상의 Promise 요청이 전달될 때, 직전 Promise 요청이 거부 되어도 다음 Promise 요청은 then 메서드를 따라간다.'],
    correctAnswer: 'Promise.all에 두 개 이상의 Promise 요청이 전달될 때, 직전 Promise 요청이 거부 되어도 다음 Promise 요청은 then 메서드를 따라간다.',
  },
  {
    question: '다음 중 리액트의 특징이 아닌 것을 고르세요.',
    options: ['리액트는 JSX로 명시적인 코드를 작성할 수 있다.', '리액트는 구조, 디자인, 동작 세가지 관심사 분리가 명확하게 된 코드를 작성할 수 있다.', '리액트를 배우면 모바일 개발을 할 수 있는 리액트 네이티브를 쉽게 배울 수 있다.'],
    correctAnswer: '리액트는 구조, 디자인, 동작 세가지 관심사 분리가 명확하게 된 코드를 작성할 수 있다.',
  },
  {
    question: '컴포넌트에 대한 설명으로 틀린 것을 고르세요.',
    options: ['하나의 기능 구현을 위한 코드 모음집이다.', '특정 레이아웃에만 적용할 수 있고 재활용 할 수 없다.', '컴포넌트를 먼저 완성시키고, 레이아웃에 따라 유동적으로 컴포넌트의 위치를 변경할 수 있는 상향식 개발 (Bottom-up) 방식에 적합하다.'],
    correctAnswer: '특정 레이아웃에만 적용할 수 있고 재활용 할 수 없다.',
  },
  {
    question: 'Create react app에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['SPA를 쉽고 빠르게 개발할 수 있도록 만들어진 툴 체인이다 .', 'Babel이나 webpack같은 build 도구를 사용하나, 따로 설정을 해주어야 한다.', 'npx create-react-app 으로 새로운 리액트 프로젝트를 시작할 수 있다.'],
    correctAnswer: 'Babel이나 webpack같은 build 도구를 사용하나, 따로 설정을 해주어야 한다.',
  },
  {
    question: '다음 중 SPA(Single Page Application)에 대한 설명으로 옳은 것을 고르세요.',
    options: ['웹사이트가 보다 복잡해지고 사용자와 더욱 많은 상호작용이 필요해 만들어졌다.', '검색 엔진 최적화(Search Engine Optimization)를 위해 만들어졌다.', 'MPA(Multi Page Application)에 비해 첫 화면 로딩 시간이 짧다.'],
    correctAnswer: '웹사이트가 보다 복잡해지고 사용자와 더욱 많은 상호작용이 필요해 만들어졌다.',
  },
  {
    question: 'React에서 컴포넌트를 효율적으로 나누는 방법 중 하나는 ________ 이다. 다음 중 빈칸에 들어갈 수 있는 내용으로 적절하지 않은 것을 고르세요.',
    options: ['와이어프레임(Wireframe)으로 먼저 어떤 컴포넌트를 만들고 조합할지 구상하는 것', '재사용이 가능한 컴포넌트를 미리 구상하는 것', '의존성이 강한 컴포넌트를 만드는 것'],
    correctAnswer: '의존성이 강한 컴포넌트를 만드는 것',
  },
  {
    question: '최신 React Router에서 사용되는 기초 문법들에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['Route 컴포넌트는 Switch 컴포넌트의 자식 컴포넌트가 되어야 한다.', 'Route의 path를 *로 설정하면 정의하지 않은 경로를 핸들링할 수 있다.', 'Link 컴포넌트는 클릭했을 때, Route의 path와 일치하는 페이지로 이동시킨다.'],
    correctAnswer: 'Route 컴포넌트는 Switch 컴포넌트의 자식 컴포넌트가 되어야 한다.',
  },
  {
    question: 'React에서 이벤트를 처리하는 방식으로 옳은 것을 고르세요.',
    options: ['이벤트 종류를 설정할 때 PascalCase로 설정해야 한다.', '이벤트에 전달하는 값은 함수여야 한다.', '이벤트 핸들러를 설정할 때 반드시 호출연산자 ()를 이용해서 바로 함수를 호출해야 한다.'],
    correctAnswer: '이벤트에 전달하는 값은 함수여야 한다.',
  },
    {
    question: 'React에서 Component 간 데이터를 전달하는 방법으로 옳은 것을 고르세요.',
    options: ['setState', 'state', 'Props'],
    correctAnswer: 'Props',
  },
  {
    question: 'useState에 대한 설명으로 틀린 것을 고르세요.',
    options: ['useState는 state를 함수 컴포넌트 안에서 사용할 수 있게 해준다.', 'useState를 사용하여 새로운 state를 선언할 때 { count, setCount } 라고 선언해야 한다.', 'useState가 반환하는 두 번째 요소는 첫 번째 요소인 state를 갱신할 수 있는 함수이다.'],
    correctAnswer: 'useState를 사용하여 새로운 state를 선언할 때 { count, setCount } 라고 선언해야 한다.',
  },
  {
    question: '이것은 웹 개발에서 사용하는 대표적인 프로토콜입니다. 기본 포트로 80을 사용하는 이것은 무엇인지 고르세요.',
    options: ['FTP', 'HTTP', 'HTTPS'],
    correctAnswer: 'HTTP',
  },
  {
    question: '다음은 HTTP 상태코드와 설명입니다. 설명 중 옳지 않은 것을 고르세요.',
    options: ['200 : OK, 성공적으로 응답을 마침', '302 : Found, 리다이렉트할 URL을 확인함', '404 : Not Acceptable, 클라이언트가 응답 코드를 받을 수 없음'],
    correctAnswer: '404 : Not Acceptable, 클라이언트가 응답 코드를 받을 수 없음',
  },
  {
    question: '다음은 HTTP Messages에 대한 설명입니다. 설명 중 옳지 않은 것을 고르세요.',
    options: ['HTTP Messages는 요청과 응답으로 나뉜다.', '요청과 응답은 유사한 구조를 가지며, 요청의 첫 번째 줄은 Start line이다.', 'GET http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1 은 URL에 새로운 정보를 입력합니다.'],
    correctAnswer: 'GET http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1 은 URL에 새로운 정보를 입력합니다.',
  },
  {
    question: 'AJAX에 대한 다음 설명 중 옳지 않은 것을 고르세요.',
    options: ['AJAX 도입 전에는 XMLHttpRequest를 이용하여 동적으로 페이지 렌더링을 했다.', '비동기적인 웹앱 제작을 위한 웹 개발 기법이다.', 'AJAX는 부분 데이터가 아니라 전체 페이지를 reload 하는 기술을 의미한다.'],
    correctAnswer: 'AJAX는 부분 데이터가 아니라 전체 페이지를 reload 하는 기술을 의미한다.',
  },
  {
    question: 'IP에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['IP는 Internet Protocol의 줄임말로, 인터넷상에서 사용하는 주소체계를 의미한다.', 'IPv4의 한계 때문에 IPv6가 생겨나게 되었고, 총 2^(128)개의 IP주소를 표현할 수 있습니다.', 'IPv4는 4개의 덩어리로 구분되어 있으며, 덩어리마다 0부터 100까지 나타낼 수 있고, 따라서 약 1억 개의 IP주소를 표현할 수 있습니다.'],
    correctAnswer: 'IPv4는 4개의 덩어리로 구분되어 있으며, 덩어리마다 0부터 100까지 나타낼 수 있고, 따라서 약 1억 개의 IP주소를 표현할 수 있습니다.',
  },
  {
    question: '다음 URI에 대한 설명으로 옳은 것을 모두 고르세요. https://www.google.com/search?q=codestates',
    options: ['url-path는 /search이다.', '해당 URI는 scheme, hosts, port만으로 이루어져 있다.', 'port 번호는 80번을 쓴다.'],
    correctAnswer: 'url-path는 /search이다.',
  },
  {
    question: '영화 예매 사이트를 개발하고 있습니다. API를 작성하며 잔여 좌석을 확인하는 GET /inquiry라는 엔드포인트를 만들었는데, REST 원칙을 준수하지 않았다는 지적을 받았습니다. 그 이유로 가장 적절한 것을 고르세요.',
    options: ['HTTP 메서드 중 GET 보다 PUT을 사용하는 것이 적절하기 때문이다.', '엔드포인트에 동사를 사용했기 때문이다.', '엔드포인트에 좌석에 대한 리소스를 지칭하지 않았기 때문이다.'],
    correctAnswer: '엔드포인트에 좌석에 대한 리소스를 지칭하지 않았기 때문이다.',
  },
  {
    question: '요리 레시피를 제공하는 웹사이트를 만들기 위해, 냉장고에 있는 재료 목록을 조회해야 합니다. 엔드포인트로(endpoint)는 어떤 것이 가장 적절한지 고르세요.',
    options: ['GET /refrigerator', 'GET /ingredient', 'POST /inquiry'],
    correctAnswer: 'GET /ingredient',
  },
  {
    question: '여러분은 트위틀러 웹사이트의 기획을 전달받은 개발자입니다. 데이터베이스에는 트윗이 너무 많으므로, 트윗 목록을 보여주기 위해 무한 스크롤을 이용해 추가적으로 트윗을 불러오려고 합니다. 이때 추가적인 트윗을 불러오기 작성해야 할 엔드포인트(endpoint)로는 어떤 것이 가장 적절한지 고르세요.',
    options: ['GET /infinite-scroll', 'GET /tweets?offset=10&limit=10', 'POST /more-tweets'],
    correctAnswer: 'GET /tweets?offset=10&limit=10',
  },
  {
    question: '여러분은 위치 기반 맛집 탐색 앱의 기획을 전달받은 개발자입니다. 특정 위치 기반의 모든 식당 목록을 조회하고, 그중 한식만 필터링하는 기능이 추가됩니다. 해당 요청을 수행하기에 알맞은 엔드포인트(endpoint)로 가장 적절한 것을 고르세요.',
    options: ['GET /filter/korean', 'GET /restaurants?coordinate=126.9178889,37.5561619&type=korean', 'GET /filter?type=korean'],
    correctAnswer: 'GET /restaurants?coordinate=126.9178889,37.5561619&type=korean',
  },
  {
    question: '게시판에서 10번 게시물을 삭제하는 엔드포인트를 작성하려고 합니다. 가장 적절한 것을 고르세요.',
    options: ['GET /delete', 'DELETE /delete', 'DELETE /articles/10'],
    correctAnswer: 'DELETE /articles/10',
  },
  {
    question: 'React 데이터 흐름에 대한 설명으로 옳은 것을 고르세요.',
    options: ['서로 다른 두 컴포넌트에 하나의 상태가 영향을 준다면, 두 컴포넌트 상위에 상태를 공유하는 컴포넌트가 존재해야 한다.', 'React 앱은 페이지 단위로 시작해 하향식으로 만드는 것이 좋다.', 'React는 state를 이용해 하위 컴포넌트로 데이터를 전달할 수 있다.'],
    correctAnswer: '서로 다른 두 컴포넌트에 하나의 상태가 영향을 준다면, 두 컴포넌트 상위에 상태를 공유하는 컴포넌트가 존재해야 한다.',
  },
  {
    question: '순수 함수에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['순수 함수는 Side Effect가 없는 함수를 말한다.', 'Math.sqrt(x)는 순수 함수이다.', '함수 내에서 Ajax 요청을 해도 함수의 결과에는 영향이 없으므로 해당 함수는 순수 함수이다.'],
    correctAnswer: '함수 내에서 Ajax 요청을 해도 함수의 결과에는 영향이 없으므로 해당 함수는 순수 함수이다.',
  },
  {
    question: 'Effect hook에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['일반적으로 반복문, 조건문 내부에서도 사용한다.', '컴포넌트 내에서 Side effect를 실행할 수 있게 하는 hook이다.', 'React 함수 내에서만 호출해야 한다.'],
    correctAnswer: '일반적으로 반복문, 조건문 내부에서도 사용한다.',
  },
  {
    question: '상태 끌어올리기에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['단방향 데이터 흐름 원칙에 부합하기 위한 개념이다.', '동일한 데이터를 여러 컴포넌트에 반영하고 싶다면 가장 가까운 공통 조상으로 state를 끌어올리는 것이 좋다.', '하위 컴포넌트에서 정의된 state를 상위 컴포넌트로 전달하는 것을 말한다.'],
    correctAnswer: '하위 컴포넌트에서 정의된 state를 상위 컴포넌트로 전달하는 것을 말한다.',
  },
  {
    question: 'React에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['컴포넌트는 React의 가장 작은 단위이다.', 'JSX에서 JavaScript 표현식을 사용하기 위해서는 중괄호({})로 씌워주어야 한다.', '어느 한 컴포넌트는 다른 컴포넌트에 속할 수 있으며, props를 통해 정보를 주고받는다.'],
    correctAnswer: '컴포넌트는 React의 가장 작은 단위이다.',
  },
  {
    question: 'CORS(Cross-Origin Resource Sharing)에 대한 설명으로 옳은 것을 고르세요.',
    options: ['같은 출처의 리소스만 공유가 가능한 정책이다.', '보안을 위해 잠재적으로 공격받을 수 있는 경로를 줄이기 위한 정책이다.', '다른 출처의 리소스를 받아오기 위해서 CORS가 등장했다.'],
    correctAnswer: '다른 출처의 리소스를 받아오기 위해서 CORS가 등장했다.',
  },
  {
    question: '프리플라이트 요청(Preflight Request)에 사용하는 메서드로 옳은 것을 고르세요.',
    options: ['GET', 'PATCH', 'OPTIONS'],
    correctAnswer: 'OPTIONS',
  },
  {
    question: '프리플라이트 요청(Preflight Request)에 대한 설명으로 옳은 것을 고르세요.',
    options: ['응답 헤더의 Access-Control-Allow-Credentials로 출처가 허용되면 실제 요청을 보낸다.', 'POST 메서드로 사전 요청을 보내 해당 출처 리소스에 접근 권한이 있는지 확인한다.', '프리플라이트 요청으로 미리 접근 권한을 확인할 수 있다'],
    correctAnswer: '프리플라이트 요청으로 미리 접근 권한을 확인할 수 있다',
  },
  {
    question: 'CORS 설정 방법에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['Node.js에서 setHeader 메서드를 이용해 설정할 수 있다.', 'Node.js에서 writeHead 메서드를 이용해 설정할 수 있다.', 'Express에서 출처 접근 권한을 설정하려면 credentials를 설정해야 한다.'],
    correctAnswer: 'Express에서 출처 접근 권한을 설정하려면 credentials를 설정해야 한다.',
  },
  {
    question: 'Express 미들웨어를 사용하는 상황으로 보기 어려운 것을 고르세요.',
    options: ['모든 요청에 대해 url이나 메서드를 확인할 때', 'POST 요청 등에 포함된 body(payload)를 구조화할 때', '단순 요청 (Simple Request)이 필요할 때'],
    correctAnswer: '단순 요청 (Simple Request)이 필요할 때',
  },
  {
    question: '다음 중 재귀 함수의 정의로 맞는 것을 고르세요.',
    options: ['함수를 호출하는 함수', '자기 자신을 호출하는 함수', '함수를 인자로 받는 함수'],
    correctAnswer: '자기 자신을 호출하는 함수',
  },
  {
    question: '다음 중 재귀 함수를 구현할 때, 재귀의 탈출 조건과 관련 있는 것을 고르세요.',
    options: ['recursive case', 'pascal case', 'base case'],
    correctAnswer: 'base case',
  },
  {
    question: '재귀를 사용하기 적합한 상황을 고르세요.',
    options: ['주어진 문제를 다양한 구조로 더 작은 문제로 나눌 수 있는 경우', '중첩된 반복문이 많거나 반복문의 중첩 횟수를 예측하기 어려운 경우', '반복문으로 표현할 수 없는 코드일 경우'],
    correctAnswer: '중첩된 반복문이 많거나 반복문의 중첩 횟수를 예측하기 어려운 경우',
  },
  {
    question: '다음 JSON에 관한 보기 중 옳은 것을 고르세요.',
    options: ['JSON.parse를 적용하는 이 과정을 직렬화(serialize)한다고 한다.', '자바스크립트의 객체와 다른 규칙을 가진다.', 'JSON.stringify를 적용하는 이 과정을 역직렬화(deserialize)한다고 한다.' ],
    correctAnswer: '자바스크립트의 객체와 다른 규칙을 가진다.',
  },
  {
    question: '다음 중 UI와 UX에 관한 설명으로 옳지 않은 것을 고르세요.',
    options: ['키보드, 마우스 같은 물리적 요소도 UI에 포함된다.', 'UX는 UI를 포함하는 개념이다.', 'UX는 제품 자체에 대한 사용자의 경험만을 말한다.'],
    correctAnswer: 'UX는 제품 자체에 대한 사용자의 경험만을 말한다.',
  },
  {
    question: '다음 중 컬럼 그리드 시스템에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['Margin, Column, Gutter의 세 가지 요소로 구성된다.', 'Margin은 고정값으로 사용해야 한다.', 'Column은 콘텐츠가 차지하게 될 영역이다.'],
    correctAnswer: 'Margin은 고정값으로 사용해야 한다.',
  },
  {
    question: '다음 중 피터 모빌의 벌집 모형이 제시한 UX의 7가지 요소에 대한 설명으로 옳은 것을 고르세요.',
    options: ['유용성은 직관적이고 사용하기 쉬운 서비스인가에 관한 요소다.', '사용성은 서비스가 기능을 제공하고 있는가에 관한 요소다.', '가치성은 모든 요소를 총합하여 사용자에게 가치를 제공하고 있는가에 관한 요소다.'],
    correctAnswer: '가치성은 모든 요소를 총합하여 사용자에게 가치를 제공하고 있는가에 관한 요소다.',
  },
  {
    question: '다음 중 user flow 다이어그램에 대해 옳지 않은 설명을 고르세요.',
    options: ['기본적으로 직사각형, 다이아몬드, 화살표를 사용해서 작성한다.', '사용자 흐름 상 어색하거나 매끄럽지 않은 부분을 발견하여 수정할 수 있다.', '기획 단계에 그려보는 것이기 때문에, 비용에는 크게 영향을 주지 않는다.'],
    correctAnswer: '기획 단계에 그려보는 것이기 때문에, 비용에는 크게 영향을 주지 않는다.',
  },
  {
    question: 'CSS in JS에 대한 설명으로 옳은 것을 고르세요.',
    options: ['CSS-in-JS에는 대표적으로 Styled-Components가 있다.', '빠른 페이지 로드에 유리하다.', '모든 스타일이 전역으로 선언되어, 복잡한 class 명명 규칙을 적용해야 하는 문제가 있다.'],
    correctAnswer: 'CSS-in-JS에는 대표적으로 Styled-Components가 있다.',
  },
  {
    question: '다음 중 useRef 에 대한 설명으로 옳은 것을 고르세요.',
    options: ['DOM 노드, 엘리먼트, 그리고 React 컴포넌트 주소값을 참조할 수 있다.', 'useRef를 통해 DOM을 직접 조작 시 리렌더링이 된다.', 'useRef를 통해 값을 저장 시 리렌더링 후 값이 초기화가 된다.'],
    correctAnswer: 'DOM 노드, 엘리먼트, 그리고 React 컴포넌트 주소값을 참조할 수 있다.',
  },
  {
    question: 'Reducer의 설명으로 옳지 않은 것을 고르시오',
    options: ['이전 상태와 동작을 받아 새 상태를 리턴하는 순수 함수입니다.', 'Reducer 함수는 Action 객체의 값을 확인하고, 그 값에 따라 전역 상태 저장소 Store의 상태를 변경합니다.', 'Action 객체의 값을 확인하고 해당 되는 경우가 없을 땐 기존 상태를 그대로 리턴하는 것보단 해당 되는 경우가 없을 때의 상태를 생성하여 리턴합니다.'],
    correctAnswer: 'Action 객체의 값을 확인하고 해당 되는 경우가 없을 땐 기존 상태를 그대로 리턴하는 것보단 해당 되는 경우가 없을 때의 상태를 생성하여 리턴합니다.',
  },
  {
    question: '다음 중 상태 변경 이벤트 발생 후 Redux에서의 데이터의 흐름으로 올바른 것을 고르세요.',
    options: ['Dispatch → Action → Store → Reducer', 'Dispatch → Action → Reducer → Store', 'Action → Dispatch → Reducer → Store'],
    correctAnswer: 'Action → Dispatch → Reducer → Store',
  },
  {
    question: '다음 중 웹 표준에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['W3C에서 권고하는 웹에서 표준적으로 사용되는 기술이나 규칙이다.', '웹 표준을 지키면 웹 호환성, 웹 접근성을 향상시킬 수 있다.', '코드가 분리되고 파일 개수가 늘어나면서 트래픽 비용은 늘어났다.'],
    correctAnswer: '코드가 분리되고 파일 개수가 늘어나면서 트래픽 비용은 늘어났다.',
  },
  {
    question: '다음 중 시맨틱 요소에 대한 설명으로 옳은 것을 고르세요.',
    options: ['<section>은 독립적으로 구분해 재사용할 수 있는 부분을 의미하는 시맨틱 요소다.', '시맨틱 요소를 잘 사용하면 웹 접근성과 검색 효율성을 높일 수 있다.', '시맨틱 요소를 사용해도 id, class 속성의 중요도는 동일하다.'],
    correctAnswer: '시맨틱 요소를 잘 사용하면 웹 접근성과 검색 효율성을 높일 수 있다.',
  },
  {
    question: '다음 중 크로스 브라우징에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['크로스 브라우징은 브라우저의 종류에 상관 없이 동등한 화면과 기능을 제공할 수 있도록 만드는 작업을 의미한다.', '인터넷 익스플로러의 지원 종료로 크로스 브라우징의 난이도가 낮아졌다.', '크로스 브라우징은 초기 기획 → 개발 → 수정 → 테스트의 단계로 이루어진다.'],
    correctAnswer: '크로스 브라우징은 초기 기획 → 개발 → 수정 → 테스트의 단계로 이루어진다.',
  },
  {
    question: '다음 중 SEO에 대한 설명으로 옳은 것을 고르세요.',
    options: ['SEO가 제대로 되지 않으면 아무도 찾지 않는 웹 페이지가 될 수도 있다.', 'SEO에는 페이지 내부에서 진행할 수 있는 Off-Page SEO, 페이지 외부에서 진행할 수 있는 On-Page SEO, 두 종류가 있다.', '효율적인 HTML 요소 사용은 Off-Page SEO의 예시다.'],
    correctAnswer: 'SEO가 제대로 되지 않으면 아무도 찾지 않는 웹 페이지가 될 수도 있다.',
  },
  {
    question: '다음 중 SEO에 영향을 미치는 요소 중 오픈그래프에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['링크를 공유했을 때 미리보기에 뜨는 내용들을 다루는 요소다.', 'og:image 속성은 <img> 요소보다 우선되어 표시된다.', 'og:description 속성이 없으면 description 속성이 미리보기에 표시된다.'],
    correctAnswer: 'og:description 속성이 없으면 description 속성이 미리보기에 표시된다.',
  },
  {
    question: '다음 중 웹 접근성에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['어떤 상황이든, 어떤 사람이든 정보를 제공받지 못하는 경우가 없도록하는 것이 웹 접근성의 목적이다.', ' 웹 접근성이 잘 갖춰져 있어도 비장애인에게는 큰 도움이 되지 않는다.', '우리나라의 웹 접근성 수준은 높은 정보화 수준에도 불구하고 높지 않다.'],
    correctAnswer: '웹 접근성이 잘 갖춰져 있어도 비장애인에게는 큰 도움이 되지 않는다.',
  },
  {
    question: '다음 중 HTTP에 대한 설명 중 틀린 것을 고르세요.',
    options: ['HTTP을 사용하면 해당 자원들을 각각 보낼 때마다 매번 연결을 반복해야 하며, 비효율성을 해결할 방안은 없습니다.', '비연결성을 가지는 HTTP에서는 실제로 요청을 주고받을 때만 연결을 유지하고 응답을 주고 나면 TCP/IP 연결을 끊습니다', 'HTTP에서는 서버가 클라이언트의 상태를 보존하지 않는 무상태 프로토콜입니다.'],
    correctAnswer: 'HTTP을 사용하면 해당 자원들을 각각 보낼 때마다 매번 연결을 반복해야 하며, 비효율성을 해결할 방안은 없습니다.',
  },
  {
    question: 'HTTP 헤더를 통해 콘텐츠 협상을 할 때, 한국어, 영어, 일본어 순으로 우선순위가 적용될 수 있는 헤더를 고르시오.',
    options: ['Accept-Language: ko,us;q=0.9,ja;q=0.8', 'Accept-Language: ko,us;q=0.1,ja;q=0.2', 'Accept-Language: ko;=0.1,us;q=0.3,ja;q=0.2'],
    correctAnswer: 'Accept-Language: ko,us;q=0.9,ja;q=0.8',
  },
  {
    question: '다음 중 HTTPS에 대한 설명으로 올바르지 않은 것을 고르세요.',
    options: ['인증서를 기반으로 데이터 제공자의 신원을 보장받을 수 있다.', '기존 HTTP 방식보다 더 안전한 통신 프로토콜이다.', '요청 및 응답을 중간에서 가로채는 중간자 공격에 취약합니다.'],
    correctAnswer: '요청 및 응답을 중간에서 가로채는 중간자 공격에 취약합니다.',
  },
  {
    question: '다음 중 쿠키에 대한 설명으로 올바른 답을 고르세요.',
    options: ['삭제하지 않는 한 항상 쿠키는 영원히 보존된다.', '모든 쿠키는 자바스크립트를 이용해서 접근할 수 있다.', '요청하는 서버의 도메인, 경로, sameSite 등의 조건이 맞아떨어질 경우 같이 전송된다.'],
    correctAnswer: '요청하는 서버의 도메인, 경로, sameSite 등의 조건이 맞아떨어질 경우 같이 전송된다.',
  },
  {
    question: '다음 중 session 기반 인증 방식에 대한 설명으로 올바르지 않은 것은?',
    options: ['서버에 접속 상태가 저장된다.', '여러 개의 서버를 가지고 있을 때 유리하다.', '신뢰할 수 있는 유저인지 확인이 가능하다.'],
    correctAnswer: '여러 개의 서버를 가지고 있을 때 유리하다.',
  },
  {
    question: 'OAuth 인증 방식에 대한 설명입니다. 틀린 것을 고르세요.',
    options: ['전통적으로 직접 작성한 서버에서 인증을 처리해주는 것과는 달리, OAuth는 인증을 중개해주는 메커니즘이다.', 'OAuth는 인증(Authentication)과 접근 권한관리(Authorization)까지 다른 서비스에게 맡기기 때문에 서버의 역할을 분담시켜줄 수 있다.', 'Authorization Code는 Authorization Grant의 한 타입으로 액세스 토큰을 발급받기 위한 Code를 의미한다.'],
    correctAnswer: 'OAuth는 인증(Authentication)과 접근 권한관리(Authorization)까지 다른 서비스에게 맡기기 때문에 서버의 역할을 분담시켜줄 수 있다.',
  },
  {
    question: '다음 중 선형구조의 자료구조가 아닌 것은?',
    options: ['배열', '트리', '스택'],
    correctAnswer: '트리',
  },
  {
    question: '스택(Stack)에 대한 개념으로 옳지 않은 것을 고르세요.',
    options: ['스택(Stack)은 먼저 들어간 데이터는 제일 나중에 나오는 후입선출(LIFO)의 구조를 가지고 있습니다.', '스택(Stack)은 하나의 입출력 방향을 가지고 있으므로 제일 위에 있는 데이터부터 차례대로 제거할 수 있습니다.', '스택(Stack) 자료구조는 데이터가 많이 들어가 있다면 데이터를 여러 개씩 넣고 뺄 수 있습니다.'],
    correctAnswer: '스택(Stack) 자료구조는 데이터가 많이 들어가 있다면 데이터를 여러 개씩 넣고 뺄 수 있습니다.',
  },
  {
    question: '큐(Queue)에 대한 개념으로 옳은 것을 고르세요.',
    options: ['큐(Queue)는 스택처럼 데이터가 아무리 많이 있어도 하나씩 데이터를 넣고 뺍니다. 한꺼번에 여러 개를 넣거나 뺄 수 없습니다.', '큐(Queue)는 하나의 입출력 방향을 가지고 있습니다. 입력과 출력의 방향이 같습니다.', '입력과 출력의 방향이 고정되어 있지 않으며, 입력의 방향으로만 접근이 가능합니다.'],
    correctAnswer: '큐(Queue)는 스택처럼 데이터가 아무리 많이 있어도 하나씩 데이터를 넣고 뺍니다. 한꺼번에 여러 개를 넣거나 뺄 수 없습니다.',
  },
  {
    question: '트리(Tree)에 대한 개념으로 옳지 않은 것을 고르세요.',
    options: ['트리(Tree)는 그래프의 여러 구조 중 단방향 그래프의 한 구조로, 하나의 뿌리로부터 가지가 사방으로 뻗은 형태가 나무와 닮아있기 때문에 트리 구조라고 부릅니다.', '트리(Tree)는 데이터가 바로 아래에 있는 하나 이상의 데이터에 양방향으로 연결된 계층적 자료구조입니다.', '트리(Tree)는 데이터를 순차적으로 나열시킨 선형 구조가 아니라, 하나의 데이터 아래에 여러 개의 데이터가 존재할 수 있는 비선형 구조입니다.'],
    correctAnswer: '트리(Tree)는 데이터가 바로 아래에 있는 하나 이상의 데이터에 양방향으로 연결된 계층적 자료구조입니다.',
  },
  {
    question: '트리 구조에 대해 올바르지 않은 것을 고르세요.',
    options: ['트리 구조는 루트(Root)라는 하나의 꼭짓점 데이터를 시작으로 여러 개의 데이터를 간선으로 연결하는 구조입니다.', '각 데이터를 노드(Node)라고 지칭하며 트리 구조를 이루는 모든 개별 데이터입니다.', '트리 안에 또 다른 트리가 존재할 수 있는데, 그것을 이너 트리(inner tree)라고 부릅니다.'],
    correctAnswer: '트리 안에 또 다른 트리가 존재할 수 있는데, 그것을 이너 트리(inner tree)라고 부릅니다.',
  },
  {
    question: '그래프(Graph)의 개념에 대해 올바르지 않은 것을 고르세요.',
    options: ['하나의 점을 그래프에서는 정점(vertex)이라고 표현하고, 하나의 선은 간선(edge)이라고 합니다.', '두 정점을 바로 이어주는 간선이 있다면 그 두 정점은 인접하다, 라고 표현하며 하나의 정점에서 간선에 의해 직접 연결되어 있는 정점을 인접 정점이라고 합니다.', '한 정점에서 출발하여 다시 해당 정점으로 다른 정점과 간선을 통해 돌아가는 것을 자기 루프(Self loop)라고 표현합니다.'],
    correctAnswer: '한 정점에서 출발하여 다시 해당 정점으로 다른 정점과 간선을 통해 돌아가는 것을 자기 루프(Self loop)라고 표현합니다.',
  },
  {
    question: '트리 순회(Tree Traversal)에 대해 올바르지 않은 것을 고르세요.',
    options: ['전위 순회는 가장 먼저 방문할 노드는 루트(root)이며, 루트에서 시작해 오른쪽의 노드를 순차적으로 둘러본 뒤 오른쪽 노드의 탐색이 끝나면 왼쪽 노드를 탐색합니다.', '중위 순회는 제일 왼쪽 끝에 있는 노드부터 순회하기 시작해 루트를 기준으로 왼쪽에 있는 노드의 순회가 끝나면 루트를 거쳐 오른쪽에 있는 노드로 이동해 마저 탐색합니다.', '후위 순회는 제일 왼쪽 끝에 있는 노드부터 순회하기 시작하여, 루트를 거치지 않고 오른쪽으로 이동해 순회한 뒤, 제일 마지막에 루트를 방문합니다.'],
    correctAnswer: '전위 순회는 가장 먼저 방문할 노드는 루트(root)이며, 루트에서 시작해 오른쪽의 노드를 순차적으로 둘러본 뒤 오른쪽 노드의 탐색이 끝나면 왼쪽 노드를 탐색합니다.',
  },
  {
    question: '이진 트리(Binary Tree)는 자료의 삽입, 삭제 방법에 따라 정 이진 트리(Full binary tree), 완전 이진 트리(Complete binary tree), 포화 이진 트리(Perfect binary tree)로 나뉩니다. 각 이진 트리의 특징으로 올바르지 않은 것을 고르세요.',
    options: ['정 이진 트리는 각 노드가 0개 혹은 1개의 자식 노드를 가집니다.', '포화 이진 트리는 정 이진 트리이면서 완전 이진 트리인 경우로, 모든 리프 노드의 레벨이 동일하고 모든 레벨이 가득 채워져 있는 트리입니다.', '포화 이진 트리에서 모든 레벨에서 노드가 꽉 차 있다는 것은 left, right 모두 존재함을 의미합니다.'],
    correctAnswer: '정 이진 트리는 각 노드가 0개 혹은 1개의 자식 노드를 가집니다.',
  },
  {
    question: '너비 우선 탐색(BFS)과 깊이 우선 탐색(DFS)에 대한 설명으로 옳은 것을 고르세요.',
    options: ['너비 우선 탐색(BFS)은 하나의 정점을 기준으로 목표하는 정점까지 가는 방법을 탐색할 때, 하나의 정점에서 가장 가까운 정점부터 탐색합니다.', '너비 우선 탐색(BFS)은 주로 두 정점 사이의 최단 경로를 찾을 때 사용하며, 처음으로 발견되는 해답이 최단 거리가 아닐 수 있습니다.', '깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS)은 모든 정점을 두 번씩 방문해야 한다는 특징이 있습니다.'],
    correctAnswer: '너비 우선 탐색(BFS)은 하나의 정점을 기준으로 목표하는 정점까지 가는 방법을 탐색할 때, 하나의 정점에서 가장 가까운 정점부터 탐색합니다.',
  },
  {
    question: 'Real DOM (DOM)에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['DOM은 Document Object Model의 약자로 JavaScript와 같은 스크립팅 언어가 <html>, <head>, <body>와 같은 태그들에 접근하고 조작할 수 있도록 태그들을 트리 구조로 객체화 시킨 것을 의미합니다.', '트리 구조로 DOM 객체가 이뤄져 있기 때문에 JavaScript는 쉽게 DOM 객체에 접근할 수 있고, DOM 객체를 조작할 수 있습니다.', 'DOM의 렌더링은 브라우저의 파워에 의존하지 않기 때문에 DOM을 아무리 조작해도 성능에 영향을 미치지 않습니다.'],
    correctAnswer: 'DOM의 렌더링은 브라우저의 파워에 의존하지 않기 때문에 DOM을 아무리 조작해도 성능에 영향을 미치지 않습니다.',
  },
  {
    question: 'Virtual DOM에 대해서 옳지 않은 것을 고르세요.',
    options: ['상대적으로 무거운 DOM에 비하여 React의 가상 DOM 객체는 실제 DOM 객체와 동일한 속성을 가지고 있음에도 “훨씬 가벼운 사본”이라고 표현할 수 있습니다', '가상 DOM 객체는 화면에 표시되는 내용을 실제 DOM 객체처럼 직접 변경하는 것까지 수행합니다.', '가상 DOM은 가상의 UI 요소를 메모리에 유지시키고, 그 유지시킨 가상의 UI 요소를 ReactDOM과 같은 라이브러리를 통해 실제 DOM과 동기화시킵니다.'],
    correctAnswer: '가상 DOM 객체는 화면에 표시되는 내용을 실제 DOM 객체처럼 직접 변경하는 것까지 수행합니다.',
  },
  {
    question: 'React가 DOM 트리를 탐색하는 방법에 대해서 옳은 것을 고르세요.',
    options: ['너비 우선 탐색(BFS)의 일종입니다.', '깊이 우선 탐색(DFS)의 일종입니다.', '후위 순회 방식의 일종입니다.'],
    correctAnswer: '너비 우선 탐색(BFS)의 일종입니다.',
  },
  {
    question: 'React가 Class 컴포넌트에서 Function 컴포넌트로 점진적으로 넘어가게 된 이유가 아닌 것을 고르세요.',
    options: ['Class 컴포넌트는 복잡해질수록 이해하기 어렵습니다.', 'JavaScript의 this 키워드가 어떤 방식으로 동작하는지 알아야 하는데, 이는 문법을 정확히 알지 못하면 동작 방식 자체를 정확히 이해하기 어렵습니다.', '상태 값을 사용하거나 최적화할 수 있는 기능들이 미진했습니다.'],
    correctAnswer: '상태 값을 사용하거나 최적화할 수 있는 기능들이 미진했습니다.',
  },
  {
    question: 'React Hook의 사용 규칙에 대해 올바른 것을 고르세요.',
    options: ['Class 컴포넌트에서도 사용할 수 있습니다.', 'React 함수의 최상위에서만 호출해야 합니다.', '반복문, 조건문, 중첩된 함수 내에서도 Hook을 작성할 수 있습니다.'],
    correctAnswer: 'React 함수의 최상위에서만 호출해야 합니다.',
  },
  {
    question: 'Custom Hook에 대한 설명으로 올바르지 않은 것을 고르세요.',
    options: ['상태관리 로직의 재활용이 가능합니다.', '클래스 컴포넌트보다 적은 양의 코드로 동일한 로직을 구현할 수 있습니다.', '꼭 use를 함수 이름 앞에 붙이지 않아도 됩니다.'],
    correctAnswer: '꼭 use를 함수 이름 앞에 붙이지 않아도 됩니다.',
  },
  {
    question: 'TypeScript에서 인터페이스와 타입 별칭(Type Alias)의 차이점으로 올바른 것은 무엇인가요?',
    options: ['인터페이스는 객체의 구조를 정의할 때 사용하며, 타입 별칭은 특정 타입에 대한 별칭을 만들 때 사용합니다.', '인터페이스와 타입 별칭은 모두 객체의 구조를 정의할 때 사용하며, 차이점은 없습니다.', '인터페이스는 클래스에서만 사용 가능하며, 타입 별칭은 함수에서만 사용 가능합니다.'],
    correctAnswer: '인터페이스는 객체의 구조를 정의할 때 사용하며, 타입 별칭은 특정 타입에 대한 별칭을 만들 때 사용합니다.',
  },
  {
    question: '클라우드 서비스의 장점으로 올바르지 않은 것을 고르세요.',
    options: ['서버의 자원과 공간, 네트워크 환경을 물리적인 컴퓨터가 아닌 가상 컴퓨터로 대여해 물리적인 한계를 극복할 수 있습니다.', '온프레미스와 같이 사용한 만큼의 요금만 지불하면 됩니다.', '컴퓨터의 스냅샷을 이용해 다른 컴퓨터로 즉시 이주(migration)가 가능합니다.'],
    correctAnswer: '온프레미스와 같이 사용한 만큼의 요금만 지불하면 됩니다.',
  },
  {
    question: '아마존 웹 서비스(AWS)에 대한 설명으로 올바르지 않은 것을 고르세요.',
    options: ['아마존 웹 서비스(AWS)는 정액제로 운영되고 있으므로 초기에 서비스를 이용하기 전 앞으로 사용할 용량을 미리 생각해야 합니다.', '매우 큰 규모의 서버 및 인프라를 구축하는 게 아니라면 네트워크나 서버 전문가가 아니더라도 사용 가능합니다.', '아마존 웹 서비스(AWS)에서만 제공하는 서비스로도 필요한 기능을 대부분 구축 가능하며, 아마존 웹 서비스(AWS) 외부 시스템을 조합하여 구축할 수도 있습니다.'],
    correctAnswer: '아마존 웹 서비스(AWS)는 정액제로 운영되고 있으므로 초기에 서비스를 이용하기 전 앞으로 사용할 용량을 미리 생각해야 합니다.',
  },
  {
    question: '클라우드와 온프레미스에 대한 설명으로 옳은 것을 고르세요.',
    options: ['클라우드 방식은 기존에 존재하는 데이터 센터와는 다르게 가상의 컴퓨터가 아닌 물리적인 컴퓨터를 대여할 수 있습니다.', '물리적으로 서버를 설치하고 증설하며 관리하던 이전 방식의 한계로 데이터 센터의 유휴 자원을 대여하는 온프레미스 방식이 도입되었습니다.', '온프레미스 방식은 데이터 센터를 세우기 시작하면서 더이상 공간의 한계에 구속받지 않으며, 주기적인 유지 관리 또한 필요 없게 되었습니다.'],
    correctAnswer: '물리적으로 서버를 설치하고 증설하며 관리하던 이전 방식의 한계로 데이터 센터의 유휴 자원을 대여하는 온프레미스 방식이 도입되었습니다.',
  },
  {
    question: '서버와 인스턴스에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['서버는 이름 그대로 어떤 ‘서비스’를 제공하는 것으로, 웹 서버라면 웹 기능을, 메일 서버라면 메일 기능을 제공합니다.', '"Amazon EC2 인스턴스를 생성한다"는 것은 AMI를 토대로 운영체제, CPU, RAM 혹은 런타임(Runtime) 등이 구성된 컴퓨터를 빌리는 것입니다.', '인스턴스는 서버로 가동되고 있는 물리 서버를 의미합니다.'],
    correctAnswer: '인스턴스는 서버로 가동되고 있는 물리 서버를 의미합니다.',
  },
  {
    question: '리전(Region)에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['리전(Region)은 전세계 여러 지역에 서버와 데이터 센터를 갖고 있으며 이를 지리적으로 분류한 것입니다.', '각 리전(Region)에는 여러 가용 영역(AZ)이 각각 가상으로 독립된 설비로 분산되어 있습니다.', '가용 영역(AZ)은 각각 물리적으로 격리되어 있으나, 좋은 품질의 네트워크 연결을 통해 논리적으로 연결되어 있어 서비스의 완전 중단을 방지합니다.'],
    correctAnswer: '각 리전(Region)에는 여러 가용 영역(AZ)이 각각 가상으로 독립된 설비로 분산되어 있습니다.',
  },
  {
    question: 'EC2 AMI에 대한 설명으로 옳은 것을 고르세요.',
    options: ['AMI는 Amazon Machine Image의 약자로, 서버를 생성할 때마다 AMI를 만들어서 사용해야 합니다', 'AWS에는 적은 양의 AMI 세팅이 준비되어 있기 때문에 인스턴스의 운영체제를 구성하기 어려운 편입니다.', 'AMI는 한 번 만들어두면 얼마든지 같은 설정의 서버를 생성하는 것이 가능해, 같은 서버를 여러 대 구축해야 할 경우 편리합니다.'],
    correctAnswer: 'AMI는 한 번 만들어두면 얼마든지 같은 설정의 서버를 생성하는 것이 가능해, 같은 서버를 여러 대 구축해야 할 경우 편리합니다.',
  },
  {
    question: 'S3의 스토리지 클래스에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['S3 사용자들이 대표적으로 많이 선택하는 스토리지 클래스로 Standard 클래스와 One Zone-IA 클래스가 있습니다.', 'Standard는 가장 범용적인 스토리지 클래스로, 데이터를 오래 보관하는 목적으로는 효율적인 선택지가 아닙니다.', 'Glacier는 데이터 아카이브와 장기간 백업을 고려해 만든 스토리지 클래스로, 가격이 낮아 대용량 데이터를 저렴한 가격으로 보관할 수 있습니다.'],
    correctAnswer: 'S3 사용자들이 대표적으로 많이 선택하는 스토리지 클래스로 Standard 클래스와 One Zone-IA 클래스가 있습니다.',
  },
  {
    question: 'S3의 웹 사이트 호스팅에 관한 설명으로 옳은 것을 고르세요.',
    options: ['S3는 정적 웹 사이트를 호스팅 할 수 있으며, 정적 웹 사이트를 호스팅 하려면 버킷을 그대로 웹 사이트로 오픈하면 됩니다.', '정적 웹 호스팅 활성화를 위해서는 공용 액세스를 차단해야 하며, 버킷 정책을 ‘특정 사용자’로 설정해야 합니다.', '버킷 명이 그대로 도메인이 되므로 버킷 명을 정할 때 주의해서 정해야 합니다.'],
    correctAnswer: 'S3는 정적 웹 사이트를 호스팅 할 수 있으며, 정적 웹 사이트를 호스팅 하려면 버킷을 그대로 웹 사이트로 오픈하면 됩니다.',
  },
  {
    question: '데이터베이스와 RDB에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['데이터베이스는 데이터를 검색하거나 특정 데이터만 추출하는 등 프로그램으로 데이터를 쉽게 조작할 수 있습니다.', '데이터베이스는 크게 관계형 데이터베이스와 비관계형 데이터베이스로 나뉩니다.', '관계형 데이터베이스는 구조가 단순하고 설정할 부분이 적으며, 비관계형 데이터베이스는 데이터의 종류까지 세세하게 설정해야 합니다.'],
    correctAnswer: '관계형 데이터베이스는 구조가 단순하고 설정할 부분이 적으며, 비관계형 데이터베이스는 데이터의 종류까지 세세하게 설정해야 합니다.',
  },
  {
    question: 'EC2에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['EC2란 Amazon Elastic Compute Cloud으로, 컴퓨팅 용량을 제공하는 서비스입니다.', 'EC2에서는 AMI라는 다양한 템플릿을 제공하고 있어서 필요에 따라 손쉽게 운영체제를 선택하고 구성할 수 있습니다.', 'EC2 인스턴스에 소프트웨어와 같은 프로그램은 설치할 수 없습니다.'],
    correctAnswer: 'EC2 인스턴스에 소프트웨어와 같은 프로그램은 설치할 수 없습니다.',
  },
  {
    question: '워터폴(Waterfall) 개발 방식의 테스트 단계에 도입된 테스트 방식에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['시스템 테스트는 모든 모듈을 통합한 후 최종적으로 완성된 시스템이 요구사항을 만족하는지 확인합니다. 요구사항을 만족하지 않는다면 다시 요구분석 단계로 돌아가 새로 개발을 하기도 합니다.', '전통적인 소프트웨어 개발 프로세스에서는 소프트웨어의 안정성 개선을 위해 테스트 단계에 다양한 테스트들을 도입하기도 합니다.', '베타 테스트는 고객의 실제 사용 환경에서 수행되는 테스트로, 기간을 두고 해당 앱을 이용하는 모든 유저가 테스터가 되어 해당 제품을 사용해 봅니다. 이 과정에서 에러나 버그가 발견되면 수정하는 식으로 진행됩니다.'],
    correctAnswer: '베타 테스트는 고객의 실제 사용 환경에서 수행되는 테스트로, 기간을 두고 해당 앱을 이용하는 모든 유저가 테스터가 되어 해당 제품을 사용해 봅니다. 이 과정에서 에러나 버그가 발견되면 수정하는 식으로 진행됩니다.',
  },
  {
    question: '애자일(Agile) 방식에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['빠르고 유연하며, 스프린트를 통한 짧은 반복 과정으로 개발 과정 중에 신속히 제품의 변경이 가능합니다.', '짧고 반복적인 스프린트로 구성되어 있어 품질에 초점을 맞출 수 있으므로 빠르게 결함을 인지하고 수정 가능합니다.', '고객은 번거롭게 중간 중간 생기는 변경 사항을 체크하는 것이 아니라 마지막에 변경 사항을 체크하면 되는 개발 방식입니다.'],
    correctAnswer: '고객은 번거롭게 중간 중간 생기는 변경 사항을 체크하는 것이 아니라 마지막에 변경 사항을 체크하면 되는 개발 방식입니다.',
  },
  {
    question: '지속적 배포(CD, Continuous Delivery/Deployment) 설명으로 옳은 것을 고르세요.',
    options: ['지속적 배포는 Code - Build - Test - Release - Deploy - Operate 전 단계에서 꾀할 수 있습니다.', '지속적 배포의 경우, 코드 변경 사항의 병합부터 프로덕션에 적합한 빌드 제공에 이르는 모든 단계로, 테스트 자동화와 코드 릴리스 자동화는 포함되지 않습니다.', '이 프로세스를 완료하면 운영팀이 보다 빠르고 손쉽게 애플리케이션을 프로덕션으로 배포할 수 있게 됩니다.'],
    correctAnswer: '이 프로세스를 완료하면 운영팀이 보다 빠르고 손쉽게 애플리케이션을 프로덕션으로 배포할 수 있게 됩니다.',
  },
  {
    question: 'Github Action에 관련된 설명으로 옳은 것을 고르세요.',
    options: ['public으로 만들지 않아도 Github Action을 무료로 이용할 수 있습니다.', '테스트가 작동하지 않는다면, Settings > Actions로 이동하여, Github Action이 활성화되었는지 확인합니다.', 'Github Action은 github의 특정한 작업 한 개를 시킬 수 있는 CI/CD 플랫폼입니다.'],
    correctAnswer: '테스트가 작동하지 않는다면, Settings > Actions로 이동하여, Github Action이 활성화되었는지 확인합니다.',
  },
  {
    question: 'YAML에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['YAML 파일은 "" (큰따옴표, double quotation marks) 없이 문자열 작성이 가능해, 설정을 위한 스펙이나 프로퍼티 값 등이 JSON 파일에 비해 한 눈에 들어옵니다.', 'JSON 파일처럼 {} 형태로 감싸줄 필요도 없기 때문에 스코프의 압박에서 벗어날 수 있습니다.', 'YAML 파일은 JSON 파일과 같이 주석을 작성할 수 없습니다.'],
    correctAnswer: 'YAML 파일은 JSON 파일과 같이 주석을 작성할 수 없습니다.',
  },
  {
    question: 'CORS 정책에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['CORS 정책은 보안을 위해 만들어진 것이며, 이러한 정책을 통해 라이브 데이터를 지킬 수 있습니다.', '서비스 및 프로젝트가 모든 출처의 접근을 허락한다면 이러한 보안성이 현저히 낮아지고, 해킹의 위험에 그대로 노출됩니다.', 'URL의 스킴(프로토콜), 호스트(도메인), 포트 중 하나라도 같다면 같은 출처를 가졌다고 합니다.'],
    correctAnswer: 'URL의 스킴(프로토콜), 호스트(도메인), 포트 중 하나라도 같다면 같은 출처를 가졌다고 합니다.',
  },
  {
    question: 'proxy에 대한 설명으로 옳지 않은 것을 고르세요.',
    options: ['proxy를 사용하면 별도의 응답 헤더를 받을 필요 없이 브라우저는 React 앱으로 데이터를 요청하고, 해당 요청을 백엔드로 전달하게 됩니다.', 'React 앱이 서버로부터 받은 응답 데이터를 다시 브라우저로 전달하는 방법을 쓰기 때문에 브라우저는 CORS 정책을 위반한 것을 알면서도 허용하게 됩니다.', 'proxy를 사용하면 React 앱이 CORS 정책을 우회하여 proxy를 통해 백엔드 서버로 요청을 보냅니다.'],
    correctAnswer: 'React 앱이 서버로부터 받은 응답 데이터를 다시 브라우저로 전달하는 방법을 쓰기 때문에 브라우저는 CORS 정책을 위반한 것을 알면서도 허용하게 됩니다.',
  },
];